// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: song.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const createSong = `-- name: CreateSong :one

INSERT INTO song (title, album, spotify_id, duration_ms, lyrics_type, lyrics)
VALUES (?, ?, ?, ?, ?, ?)
RETURNING id, title, spotify_id, duration_ms, album, lyrics_type, lyrics
`

type CreateSongParams struct {
	Title      string
	Album      string
	SpotifyID  string
	DurationMs int64
	LyricsType sql.NullString
	Lyrics     sql.NullString
}

// CRUD
func (q *Queries) CreateSong(ctx context.Context, arg CreateSongParams) (Song, error) {
	row := q.db.QueryRowContext(ctx, createSong,
		arg.Title,
		arg.Album,
		arg.SpotifyID,
		arg.DurationMs,
		arg.LyricsType,
		arg.Lyrics,
	)
	var i Song
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SpotifyID,
		&i.DurationMs,
		&i.Album,
		&i.LyricsType,
		&i.Lyrics,
	)
	return i, err
}

const createSongArtist = `-- name: CreateSongArtist :one
INSERT INTO song_artist (name, spotify_id, followers, popularity)
VALUES (?, ?, ?, ?)
RETURNING id, name, spotify_id, followers, popularity
`

type CreateSongArtistParams struct {
	Name       string
	SpotifyID  string
	Followers  int64
	Popularity int64
}

func (q *Queries) CreateSongArtist(ctx context.Context, arg CreateSongArtistParams) (SongArtist, error) {
	row := q.db.QueryRowContext(ctx, createSongArtist,
		arg.Name,
		arg.SpotifyID,
		arg.Followers,
		arg.Popularity,
	)
	var i SongArtist
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.SpotifyID,
		&i.Followers,
		&i.Popularity,
	)
	return i, err
}

const createSongArtistGenre = `-- name: CreateSongArtistGenre :one
INSERT INTO song_artist_genre (artist_id, genre_id)
VALUES (?, ?)
RETURNING id, artist_id, genre_id
`

type CreateSongArtistGenreParams struct {
	ArtistID int64
	GenreID  int64
}

func (q *Queries) CreateSongArtistGenre(ctx context.Context, arg CreateSongArtistGenreParams) (SongArtistGenre, error) {
	row := q.db.QueryRowContext(ctx, createSongArtistGenre, arg.ArtistID, arg.GenreID)
	var i SongArtistGenre
	err := row.Scan(&i.ID, &i.ArtistID, &i.GenreID)
	return i, err
}

const createSongArtistSong = `-- name: CreateSongArtistSong :one
INSERT INTO song_artist_song (artist_id, song_id)
VALUES (?, ?)
RETURNING id, artist_id, song_id
`

type CreateSongArtistSongParams struct {
	ArtistID int64
	SongID   int64
}

func (q *Queries) CreateSongArtistSong(ctx context.Context, arg CreateSongArtistSongParams) (SongArtistSong, error) {
	row := q.db.QueryRowContext(ctx, createSongArtistSong, arg.ArtistID, arg.SongID)
	var i SongArtistSong
	err := row.Scan(&i.ID, &i.ArtistID, &i.SongID)
	return i, err
}

const createSongGenre = `-- name: CreateSongGenre :one
INSERT INTO song_genre (genre)
VALUES (?)
RETURNING id, genre
`

func (q *Queries) CreateSongGenre(ctx context.Context, genre string) (SongGenre, error) {
	row := q.db.QueryRowContext(ctx, createSongGenre, genre)
	var i SongGenre
	err := row.Scan(&i.ID, &i.Genre)
	return i, err
}

const createSongHistory = `-- name: CreateSongHistory :one
INSERT INTO song_history (song_id)
VALUES (?)
RETURNING id, song_id, created_at
`

func (q *Queries) CreateSongHistory(ctx context.Context, songID int64) (SongHistory, error) {
	row := q.db.QueryRowContext(ctx, createSongHistory, songID)
	var i SongHistory
	err := row.Scan(&i.ID, &i.SongID, &i.CreatedAt)
	return i, err
}

const getLastSongFull = `-- name: GetLastSongFull :many
SELECT s.id, s.title AS song_title, s.spotify_id, s.album, s.duration_ms, s.lyrics_type, s.lyrics, sh.created_at, a.id AS artist_id, a.name AS artist_name, a.spotify_id AS artist_spotify_id, a.followers AS artist_followers, a.popularity AS artist_popularity, g.id AS genre_id, g.genre AS genre, sh.created_at
FROM song_history sh
JOIN song s ON sh.song_id = s.id
LEFT JOIN song_artist_song sa ON s.id = sa.song_id
LEFT JOIN song_artist a ON sa.artist_id = a.id
LEFT JOIN song_artist_genre ag ON ag.artist_id = a.id
LEFT JOIN song_genre g ON ag.genre_id = g.id
WHERE sh.created_at = (SELECT MAX(created_at) FROM song_history)
ORDER BY a.name, g.genre
`

type GetLastSongFullRow struct {
	ID               int64
	SongTitle        string
	SpotifyID        string
	Album            string
	DurationMs       int64
	LyricsType       sql.NullString
	Lyrics           sql.NullString
	CreatedAt        time.Time
	ArtistID         sql.NullInt64
	ArtistName       sql.NullString
	ArtistSpotifyID  sql.NullString
	ArtistFollowers  sql.NullInt64
	ArtistPopularity sql.NullInt64
	GenreID          sql.NullInt64
	Genre            sql.NullString
	CreatedAt_2      time.Time
}

func (q *Queries) GetLastSongFull(ctx context.Context) ([]GetLastSongFullRow, error) {
	rows, err := q.db.QueryContext(ctx, getLastSongFull)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLastSongFullRow
	for rows.Next() {
		var i GetLastSongFullRow
		if err := rows.Scan(
			&i.ID,
			&i.SongTitle,
			&i.SpotifyID,
			&i.Album,
			&i.DurationMs,
			&i.LyricsType,
			&i.Lyrics,
			&i.CreatedAt,
			&i.ArtistID,
			&i.ArtistName,
			&i.ArtistSpotifyID,
			&i.ArtistFollowers,
			&i.ArtistPopularity,
			&i.GenreID,
			&i.Genre,
			&i.CreatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastSongHistory = `-- name: GetLastSongHistory :one
SELECT id, song_id, created_at
FROM song_history
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetLastSongHistory(ctx context.Context) (SongHistory, error) {
	row := q.db.QueryRowContext(ctx, getLastSongHistory)
	var i SongHistory
	err := row.Scan(&i.ID, &i.SongID, &i.CreatedAt)
	return i, err
}

const getSongArtistByName = `-- name: GetSongArtistByName :one
SELECT id, name, spotify_id, followers, popularity
FROM song_artist
WHERE name = ?
`

func (q *Queries) GetSongArtistByName(ctx context.Context, name string) (SongArtist, error) {
	row := q.db.QueryRowContext(ctx, getSongArtistByName, name)
	var i SongArtist
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.SpotifyID,
		&i.Followers,
		&i.Popularity,
	)
	return i, err
}

const getSongArtistBySpotifyID = `-- name: GetSongArtistBySpotifyID :one
SELECT id, name, spotify_id, followers, popularity
FROM song_artist
WHERE spotify_id = ?
`

func (q *Queries) GetSongArtistBySpotifyID(ctx context.Context, spotifyID string) (SongArtist, error) {
	row := q.db.QueryRowContext(ctx, getSongArtistBySpotifyID, spotifyID)
	var i SongArtist
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.SpotifyID,
		&i.Followers,
		&i.Popularity,
	)
	return i, err
}

const getSongBySpotifyID = `-- name: GetSongBySpotifyID :one

SELECT id, title, spotify_id, duration_ms, album, lyrics_type, lyrics
FROM song
WHERE spotify_id = ?
`

// Other
func (q *Queries) GetSongBySpotifyID(ctx context.Context, spotifyID string) (Song, error) {
	row := q.db.QueryRowContext(ctx, getSongBySpotifyID, spotifyID)
	var i Song
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SpotifyID,
		&i.DurationMs,
		&i.Album,
		&i.LyricsType,
		&i.Lyrics,
	)
	return i, err
}

const getSongGenreByName = `-- name: GetSongGenreByName :one
SELECT id, genre
FROM song_genre
WHERE genre = ?
`

func (q *Queries) GetSongGenreByName(ctx context.Context, genre string) (SongGenre, error) {
	row := q.db.QueryRowContext(ctx, getSongGenreByName, genre)
	var i SongGenre
	err := row.Scan(&i.ID, &i.Genre)
	return i, err
}

const getSongHistory = `-- name: GetSongHistory :many
SELECT s.title
FROM song_history sh
JOIN song s  ON sh.song_id = s.id
ORDER BY created_at DESC
LIMIT 5
`

func (q *Queries) GetSongHistory(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getSongHistory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var title string
		if err := rows.Scan(&title); err != nil {
			return nil, err
		}
		items = append(items, title)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopArtists = `-- name: GetTopArtists :many
SELECT sa.id AS artist_id, sa.name AS artist_name, COUNT(sh.id) AS total_plays
FROM song_history sh
JOIN song s ON sh.song_id = s.id
JOIN song_artist_song sas ON s.id = sas.song_id
JOIN song_artist sa ON sas.artist_id = sa.id
GROUP BY sa.id, sa.name
ORDER BY total_plays DESC
LIMIT 5
`

type GetTopArtistsRow struct {
	ArtistID   int64
	ArtistName string
	TotalPlays int64
}

func (q *Queries) GetTopArtists(ctx context.Context) ([]GetTopArtistsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopArtists)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopArtistsRow
	for rows.Next() {
		var i GetTopArtistsRow
		if err := rows.Scan(&i.ArtistID, &i.ArtistName, &i.TotalPlays); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopGenres = `-- name: GetTopGenres :many
SELECT g.genre AS genre_name, COUNT(sh.id) AS total_plays
FROM song_history sh
JOIN song s ON sh.song_id = s.id
JOIN song_artist_song sas ON s.id = sas.song_id
JOIN song_artist sa ON sas.artist_id = sa.id
JOIN song_artist_genre sag ON sa.id = sag.artist_id
JOIN song_genre g ON sag.genre_id = g.id
GROUP BY g.genre
ORDER BY total_plays DESC
LIMIT 5
`

type GetTopGenresRow struct {
	GenreName  string
	TotalPlays int64
}

func (q *Queries) GetTopGenres(ctx context.Context) ([]GetTopGenresRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopGenres)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopGenresRow
	for rows.Next() {
		var i GetTopGenresRow
		if err := rows.Scan(&i.GenreName, &i.TotalPlays); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopSongs = `-- name: GetTopSongs :many
SELECT s.id AS song_id, s.title, COUNT(sh.id) AS play_count
FROM song_history sh
JOIN song s ON sh.song_id = s.id
GROUP BY s.id, s.title
ORDER BY play_count DESC
LIMIT 5
`

type GetTopSongsRow struct {
	SongID    int64
	Title     string
	PlayCount int64
}

func (q *Queries) GetTopSongs(ctx context.Context) ([]GetTopSongsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopSongs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopSongsRow
	for rows.Next() {
		var i GetTopSongsRow
		if err := rows.Scan(&i.SongID, &i.Title, &i.PlayCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
