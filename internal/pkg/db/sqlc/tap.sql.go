// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: tap.sql

package sqlc

import (
	"context"
	"time"
)

const createTap = `-- name: CreateTap :one
INSERT INTO tap (order_id, order_created_at, name, category)
VALUES (?, ?, ?, ?)
RETURNING id, order_id, order_created_at, name, category, created_at
`

type CreateTapParams struct {
	OrderID        int64
	OrderCreatedAt time.Time
	Name           string
	Category       string
}

func (q *Queries) CreateTap(ctx context.Context, arg CreateTapParams) (Tap, error) {
	row := q.db.QueryRowContext(ctx, createTap,
		arg.OrderID,
		arg.OrderCreatedAt,
		arg.Name,
		arg.Category,
	)
	var i Tap
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.OrderCreatedAt,
		&i.Name,
		&i.Category,
		&i.CreatedAt,
	)
	return i, err
}

const deleteTap = `-- name: DeleteTap :execrows
DELETE FROM tap
WHERE id = ?
`

func (q *Queries) DeleteTap(ctx context.Context, id int64) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteTap, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getAllTaps = `-- name: GetAllTaps :many

SELECT id, order_id, order_created_at, name, category, created_at
FROM tap
`

// CRUD
func (q *Queries) GetAllTaps(ctx context.Context) ([]Tap, error) {
	rows, err := q.db.QueryContext(ctx, getAllTaps)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tap
	for rows.Next() {
		var i Tap
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.OrderCreatedAt,
			&i.Name,
			&i.Category,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastOrderByOrderID = `-- name: GetLastOrderByOrderID :one
SELECT id, order_id, order_created_at, name, category, created_at
FROM tap
ORDER BY order_id DESC
LIMIT 1
`

func (q *Queries) GetLastOrderByOrderID(ctx context.Context) (Tap, error) {
	row := q.db.QueryRowContext(ctx, getLastOrderByOrderID)
	var i Tap
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.OrderCreatedAt,
		&i.Name,
		&i.Category,
		&i.CreatedAt,
	)
	return i, err
}

const getOrderCount = `-- name: GetOrderCount :many
SELECT category, COUNT(*)
FROM tap
GROUP BY category
`

type GetOrderCountRow struct {
	Category string
	Count    int64
}

func (q *Queries) GetOrderCount(ctx context.Context) ([]GetOrderCountRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrderCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrderCountRow
	for rows.Next() {
		var i GetOrderCountRow
		if err := rows.Scan(&i.Category, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderCountByCategorySinceOrderID = `-- name: GetOrderCountByCategorySinceOrderID :many
SELECT category, COUNT(*)
FROM tap
WHERE order_id >= ?
GROUP BY category
`

type GetOrderCountByCategorySinceOrderIDRow struct {
	Category string
	Count    int64
}

func (q *Queries) GetOrderCountByCategorySinceOrderID(ctx context.Context, orderID int64) ([]GetOrderCountByCategorySinceOrderIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrderCountByCategorySinceOrderID, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrderCountByCategorySinceOrderIDRow
	for rows.Next() {
		var i GetOrderCountByCategorySinceOrderIDRow
		if err := rows.Scan(&i.Category, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTapByCategory = `-- name: GetTapByCategory :many
SELECT id, order_id, order_created_at, name, category, created_at
FROM tap
WHERE category = ?
`

func (q *Queries) GetTapByCategory(ctx context.Context, category string) ([]Tap, error) {
	rows, err := q.db.QueryContext(ctx, getTapByCategory, category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tap
	for rows.Next() {
		var i Tap
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.OrderCreatedAt,
			&i.Name,
			&i.Category,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTapByID = `-- name: GetTapByID :one
SELECT id, order_id, order_created_at, name, category, created_at
FROM tap
WHERE id = ?
`

func (q *Queries) GetTapByID(ctx context.Context, id int64) (Tap, error) {
	row := q.db.QueryRowContext(ctx, getTapByID, id)
	var i Tap
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.OrderCreatedAt,
		&i.Name,
		&i.Category,
		&i.CreatedAt,
	)
	return i, err
}

const getTapByOrderID = `-- name: GetTapByOrderID :one

SELECT id, order_id, order_created_at, name, category, created_at
FROM tap
WHERE order_id = ?
`

// Other
func (q *Queries) GetTapByOrderID(ctx context.Context, orderID int64) (Tap, error) {
	row := q.db.QueryRowContext(ctx, getTapByOrderID, orderID)
	var i Tap
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.OrderCreatedAt,
		&i.Name,
		&i.Category,
		&i.CreatedAt,
	)
	return i, err
}

const updateTap = `-- name: UpdateTap :one
UPDATE tap
SET order_id = ?, order_created_at = ?, name = ?, category = ?
WHERE id = ?
RETURNING id, order_id, order_created_at, name, category, created_at
`

type UpdateTapParams struct {
	OrderID        int64
	OrderCreatedAt time.Time
	Name           string
	Category       string
	ID             int64
}

func (q *Queries) UpdateTap(ctx context.Context, arg UpdateTapParams) (Tap, error) {
	row := q.db.QueryRowContext(ctx, updateTap,
		arg.OrderID,
		arg.OrderCreatedAt,
		arg.Name,
		arg.Category,
		arg.ID,
	)
	var i Tap
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.OrderCreatedAt,
		&i.Name,
		&i.Category,
		&i.CreatedAt,
	)
	return i, err
}
