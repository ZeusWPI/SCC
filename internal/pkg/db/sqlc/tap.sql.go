// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: tap.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTap = `-- name: CreateTap :one
INSERT INTO tap (order_id, order_created_at, name, category)
VALUES ($1, $2, $3, $4)
RETURNING id, order_id, order_created_at, name, category, created_at
`

type CreateTapParams struct {
	OrderID        int32
	OrderCreatedAt pgtype.Timestamptz
	Name           string
	Category       string
}

func (q *Queries) CreateTap(ctx context.Context, arg CreateTapParams) (Tap, error) {
	row := q.db.QueryRow(ctx, createTap,
		arg.OrderID,
		arg.OrderCreatedAt,
		arg.Name,
		arg.Category,
	)
	var i Tap
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.OrderCreatedAt,
		&i.Name,
		&i.Category,
		&i.CreatedAt,
	)
	return i, err
}

const deleteTap = `-- name: DeleteTap :execrows
DELETE FROM tap
WHERE id = $1
`

func (q *Queries) DeleteTap(ctx context.Context, id int32) (int64, error) {
	result, err := q.db.Exec(ctx, deleteTap, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getAllTaps = `-- name: GetAllTaps :many

SELECT id, order_id, order_created_at, name, category, created_at
FROM tap
`

// CRUD
func (q *Queries) GetAllTaps(ctx context.Context) ([]Tap, error) {
	rows, err := q.db.Query(ctx, getAllTaps)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tap
	for rows.Next() {
		var i Tap
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.OrderCreatedAt,
			&i.Name,
			&i.Category,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastOrderByOrderID = `-- name: GetLastOrderByOrderID :one
SELECT id, order_id, order_created_at, name, category, created_at
FROM tap
ORDER BY order_id DESC
LIMIT 1
`

func (q *Queries) GetLastOrderByOrderID(ctx context.Context) (Tap, error) {
	row := q.db.QueryRow(ctx, getLastOrderByOrderID)
	var i Tap
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.OrderCreatedAt,
		&i.Name,
		&i.Category,
		&i.CreatedAt,
	)
	return i, err
}

const getOrderCount = `-- name: GetOrderCount :many
SELECT category, COUNT(*)
FROM tap
GROUP BY category
`

type GetOrderCountRow struct {
	Category string
	Count    int64
}

func (q *Queries) GetOrderCount(ctx context.Context) ([]GetOrderCountRow, error) {
	rows, err := q.db.Query(ctx, getOrderCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrderCountRow
	for rows.Next() {
		var i GetOrderCountRow
		if err := rows.Scan(&i.Category, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderCountByCategorySinceOrderID = `-- name: GetOrderCountByCategorySinceOrderID :many
SELECT category, COUNT(*), MAX(order_created_at)::TIMESTAMP AS latest_order_created_at
FROM tap
WHERE order_id >= $1
GROUP BY category
`

type GetOrderCountByCategorySinceOrderIDRow struct {
	Category             string
	Count                int64
	LatestOrderCreatedAt pgtype.Timestamp
}

func (q *Queries) GetOrderCountByCategorySinceOrderID(ctx context.Context, orderID int32) ([]GetOrderCountByCategorySinceOrderIDRow, error) {
	rows, err := q.db.Query(ctx, getOrderCountByCategorySinceOrderID, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrderCountByCategorySinceOrderIDRow
	for rows.Next() {
		var i GetOrderCountByCategorySinceOrderIDRow
		if err := rows.Scan(&i.Category, &i.Count, &i.LatestOrderCreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTapByCategory = `-- name: GetTapByCategory :many
SELECT id, order_id, order_created_at, name, category, created_at
FROM tap
WHERE category = $1
`

func (q *Queries) GetTapByCategory(ctx context.Context, category string) ([]Tap, error) {
	rows, err := q.db.Query(ctx, getTapByCategory, category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tap
	for rows.Next() {
		var i Tap
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.OrderCreatedAt,
			&i.Name,
			&i.Category,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTapByID = `-- name: GetTapByID :one
SELECT id, order_id, order_created_at, name, category, created_at
FROM tap
WHERE id = $1
`

func (q *Queries) GetTapByID(ctx context.Context, id int32) (Tap, error) {
	row := q.db.QueryRow(ctx, getTapByID, id)
	var i Tap
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.OrderCreatedAt,
		&i.Name,
		&i.Category,
		&i.CreatedAt,
	)
	return i, err
}

const getTapByOrderID = `-- name: GetTapByOrderID :one


SELECT id, order_id, order_created_at, name, category, created_at
FROM tap
WHERE order_id = $1
`

// Other
func (q *Queries) GetTapByOrderID(ctx context.Context, orderID int32) (Tap, error) {
	row := q.db.QueryRow(ctx, getTapByOrderID, orderID)
	var i Tap
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.OrderCreatedAt,
		&i.Name,
		&i.Category,
		&i.CreatedAt,
	)
	return i, err
}

const updateTap = `-- name: UpdateTap :one
UPDATE tap
SET order_id = $1, order_created_at = $2, name = $3, category = $4
WHERE id = $5
RETURNING id, order_id, order_created_at, name, category, created_at
`

type UpdateTapParams struct {
	OrderID        int32
	OrderCreatedAt pgtype.Timestamptz
	Name           string
	Category       string
	ID             int32
}

func (q *Queries) UpdateTap(ctx context.Context, arg UpdateTapParams) (Tap, error) {
	row := q.db.QueryRow(ctx, updateTap,
		arg.OrderID,
		arg.OrderCreatedAt,
		arg.Name,
		arg.Category,
		arg.ID,
	)
	var i Tap
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.OrderCreatedAt,
		&i.Name,
		&i.Category,
		&i.CreatedAt,
	)
	return i, err
}
